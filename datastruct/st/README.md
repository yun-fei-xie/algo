# Sparse-Table

Sparse-Table简称st，是由torjan提出的一种解决RMQ问题的算法。
只能处理静态类型的区间查询，不能处理动态的。（不支持修改数据）
它的离线数据预处理的时间复杂度是O(nlogn)，离线查询的时间复杂度是O(1)

## 一个例子

### 区间查询

假设现在有一个数组，它的数据不需要被更改，我们需要对这个数组做一些查询操作。

```text
arr  = [5,3,7,2,12,1]
```

我希望给定一组query={{left ,right} ,{} ...{}}表示每次区间查询的左右端点。
请返回区间查询的最大值。
例如：query=[3,5] 表示询问arr[3...5]这段区间中的最大值是多少？（答案是max{arr[3],arr[4],arr[5]}->12 arr[4]）

### 尝试解决

1. 每次拿到一个左右区间的范围[left ,right] ,然后写一个for循环扫描一遍数组

```text
for i:=left ;i<=right ;i++ {
    ans = max(ans , arr[i])
   }
}
```

这样的做法是简单但是比较低效的。因为我们的查询可能会有很多很多，每次都要扫描数组是比较慢的。
试想这样的场景，query数组有100万个元素，意味着查询量有一百万，但是其中有大量的重复查询。
意味着有很多查询是在查询相同的区间元素，这样我们的算法会做很多重复的扫描工作。

2. 能不能用缓存?
   一个在计算机中比较常用的改进方式是：能不能上缓存？
   假设我能够穷举所有的查询区间，然后求出每一个区间中的最大值，并存储在一张表格中。
   当有查询过来的时候，自己去表格中找出对用的答案。这样是不是就比较高效。

来尝试构造一下这张表格:
例如，对于arr这个数组来说，它的长度为6，也就是在区间查询中，最大的有效区间长度就是6。

```text
arr  = [5,3,7,2,12,1]
```

那么也就意味着，查询的区间长度在[1...6]之间浮动。
有了区间的长度范围，来看看区间的起始点，对于5这个元素（下标为0）来说，它的区间起始点为0。
以它为起点的元素可以承担的区间查询长度在[1...6]
同理，对于3来说，它可以承担的区间查询长度在[1...5]...
最后，对于1来说，它可以承担的区间查询长度只有[1...1]
于是，可以构造一个二维的表格f[i][j] ，它表示以i为起点，区间长度为j的子数组中的最大值。

假设有了这样一个二维表格之后，给出query = [2,5]，那么我们就能知道，区间的起始点是2，长度为4（right-left+1）。
那么直接返回f[2][4]即可。（时间复杂度为O(1)）

3. 如何高效填充这个二维表格？
   首先，用暴力的方式填充这个二维表格肯定是可以的。
   以5这个起点(下标为0)为例：
   `f[0][1]= 5` 毫无疑问，这个区间只有它一个元素。
   `f[0][2]=?` 很明显，我们已经知道了以5为起点，区间长度为1的这段区间的最大值，那么`f[0][2] = max{f[0][1] ,arr[0+2]}`
   剩下的位置，依次类推。于是可以得到第一个版本的填充方式。

```text
	// 填写表格
	for i := 0; i < len(arr); i++ {
		s[i][1] = arr[i]
	}
	for i := 0; i < len(arr); i++ {
		for j := 2; j <= len(arr) && (i+j-1) < len(arr); j++ {
			s[i][j] = max(s[i][j-1], arr[i+j-1])
		}
	}
```

这是一个类似动态规划的递推方程。
首先填写base case，也就是区间长度为1的情况，它是后序递推的基础。
遍历每一个起始点i，填写它们能够满足的合法的长度j。
如何判断长度是否合法呢？

1. 区间的最大长度不应该超过整个数组的长度。
2. 区间的末尾下标不能越过数组的右边界。（起点+长度-1 -> 区间末尾下标）

完成的demo代码：

```text

import (
	"fmt"
	"testing"
)

/*
st表的简单示例，给定一个数组，查询数组中的区间最大值
*/
type sTable struct {
	st [][]int
}

func newST(arr []int) *sTable {
	maxLength := len(arr)
	maxIndex := len(arr) - 1
	s := make([][]int, maxIndex+1) // [0...maxIndex]
	for i := 0; i < len(s); i++ {
		s[i] = make([]int, maxLength+1) //[1...maxLength]
	}

	// 填写表格
	for i := 0; i < len(arr); i++ {
		s[i][1] = arr[i]
	}
	for i := 0; i < len(arr); i++ {
		for j := 2; j <= maxLength && (i+j-1) < len(arr); j++ {
			s[i][j] = max(s[i][j-1], arr[i+j-1])
		}
	}
	return &sTable{st: s}
}
func max(i, j int) int {
	if i > j {
		return i
	}
	return j
}

/*
查询操作
*/
func (st *sTable) query(queries [][]int) (ans []int) {
	for _, query := range queries {
		left := query[0]
		length := query[1] - query[0] + 1
		ans = append(ans, st.st[left][length])
	}
	return ans
}

func TestSt(t *testing.T) {
	arr := []int{5, 3, 7, 2, 12, 1} //[0...5]
	st := newST(arr)
	queries := [][]int{{0, 1}, {0, 4}, {1, 3}, {1, 2}, {3, 5}, {2, 5}}
	ans := st.query(queries)
	fmt.Println(ans)
}
```

### 能否优化

上面的代码比较容易想出，无论是写起来还是看起来都比较直观。
但是有一个问题，st这个矩阵的的空间利用率怎么样？

```text
arr := []int{5, 3, 7, 2, 12, 1} //[0...5]
```

以arr为例，在代码中开st表空间的时候，它的行数i的范围是[0...5]一共有6行，列数j的范围是[1...6]加上浪费的0，一共7列。
总的空间是n*(n+1)。
实际上，我们填写了多少个元素呢？

```text
i=0 -> 填写了len(arr)个位置
i=1 -> 填写了len(arr)-1个位置
...
...
...
i=len(arr)-1 ->填写了1个位置
```

这是一个等差数列，总计有len(arr)项，公差为1,很容易算出填写了（len(arr) + 1） * (len(arr)) /2 。len(arr)= n
得到 (n+1)*n/2。也就是浪费了一半的数组空间。





