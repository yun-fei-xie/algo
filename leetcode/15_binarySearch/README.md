# 二分查找

## 基础二分

1. 数组中无重复元素，找出数组中元素==target的下标
假设在下面的数组中寻找元素5所在位置的下标
```text
arr ->[ 1, 2, 3, 4, 5, 6 ,7 ]
        l        m        r
如果arr[m] < 5 ,可以知道arr[l...m]<5，这段区间可以不用考察，更新l=m+1


arr ->[ 1, 2, 3, 4, 5, 6 ,7 ]
                    l  m  r
如果arr[m] > 5, 可以知道arr[m...r]>5,这段区间可以不用考察，更新r=m-1


arr ->[ 1, 2, 3, 4, 5, 6 ,7 ]
                   lmr
```

如果找一个不存在的数字，会怎出现什么情况，最后的l、r两个指针分别停在什么地方？

```text
target->29
arr ->[ 1, 3, 5, 17, 19, 31, 30 ,55 ]
        l        m               r

第一次更新 arr[m]<29，于是arr[l...m]<29，更新l=m+1
arr ->[ 1, 3, 5, 17, 19, 31, 30 ,55 ]
                      l  m       r
                      
第二次更新 arr[m]>29，于是arr[m...r]>29，更新r=m-1
arr ->[ 1, 3, 5, 17, 19, 31, 30 ,55 ]
                     lmr         
 
第三次更新 arr[m]<29，于是arr[l...m]<29,更新l=m+1
arr ->[ 1, 3, 5, 17, 19, 31, 30 ,55 ]
                      r  l  
此时出现l>r,所有元素都遍历完毕，没有找到答案。
```


## 二分变种

### 找出有重复数字的数组中满足arr[i]==target的第一个元素
写法上依然分为3个判断：大于、小于、等于。分别讨论三种情况下的指针策略
查第一个出现的元素，倾向去左边查找；
查最后一个出现的元素，倾向去右边查找；

1. 如果arr[mid] < target，则有arr[l...mid] < target。此时应该去右边查找，更新l=mid+1。
2. 如果arr[mid] > target，则有arr[mid...r] > target。此时应该去左边查找，更新r=mid-1。
3. 如果arr[mid] ==target？必然有arr[mid...r]>=target。由于要查第一个出现的元素，倾向于左边查找。
    这里可以先判断一下（mid-1>=0 && arr[mid-1] != target）
4. 最后的指针

```text

target->19
arr ->[ 1, 3, 5, 17, 17, 19, 19, 31, 30 ,55 ]
        l                                r
初始时，l=0 ,r=9  限制条件:l<=r 

第一次询问:
arr ->[ 1, 3, 5, 17, 17, 19, 19, 31, 30 ,55 ]
        l            m                    r
arr[m]<target 说明arr[l...m]<target 更新l=m+1


第二次询问：
arr ->[ 1, 3, 5, 17, 17, 19, 19, 31, 30 ,55 ]
                         l       m       r
arr[m]>target 说明arr[m...r]>target 更新r=m-1


第三次询问：
arr ->[ 1, 3, 5, 17, 17, 19, 19, 31, 30 ,55 ]
                         lm   r   
arr[m]==target 说明arr[m...r]>=target 更新r=m-1


第四次询问：
arr ->[ 1, 3, 5, 17, 17, 19, 19, 31, 30 ,55 ]
                      r  lm   
不满足l<=r 。此时如果存在解的话，就是r+1这个位置。（也可能不存在解）
if arr[r+1]==target 那么它就是第一个。
if arr[r+1]!=target 那么无解。
```



### 找出有重复数字的数组中满足arr[i]==target的最后一个元素




